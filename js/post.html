<!-- Pre-load large images of demo -->
<div style="overflow:hidden; width:0px; height: 0px; pointer-events:none;">
    <img src="http://tympanus.net/Development/NAME/img/something.jpg" style="width: 0; height: 0; opacity: 0;"/>
  </div>
  
  After introductory paragraph: 
  
  <div class="ct-featured-img-rss"><a href="http://tympanus.net/Development/NAME/"><!-- Featured Image for RSS Feed --></a></div>
  
  <strong>The demo is kindly sponsored by <a href="" rel="nofollow"></a></strong>. <em>If you would like to sponsor one of our demos, find out more <a href="https://tympanus.net/codrops/advertise/#advertise_demo">here</a>.</em>
  
  
  <!-- ===================================== -->
  <!-- For contributors writing the article: -->



  <p>We've done some crazy <a href="https://tympanus.net/Development/PolygonalTransitions/index.html">polygon transitions</a> lately, and before that some <a href="https://tympanus.net/codrops/2019/11/05/creative-webgl-image-transitions/">WebGl Image Transitions</a>. But a lot of people have been asking, on how to translate those techniques into the video world. And i agree, one could not underestimate the power of video. So let's do this!</p>
  <figure>
    <video src="media/start.mp4" muted autoplay loop width="600"></video>
    <figcaption>
        Just press play, and see this smooth video transition
    </figcaption>
  </figure>
  
  <h2>What library?</h2>  
  <p>Three.js is the industry standard for creating WebGL effects, but we already had a lot of demos with it. And there are a lot of other awesome WebGL libraries out there. All with a different kind of focus and purpose. So let's dive into one of them!</p>
  <h3>Curtains.js</h3>
  <p>A library made by <a href="https://twitter.com/webdesign_ml">Martin Laxenaire</a>. It was just recently updated with a lot of cool stuff, and i decided to use it for this demo.</p>
  <p>The focus of this library is stated right on the homepage:</p>
  <blockquote><p>A lot of very good javascript libraries already handle WebGL but with most of them it's kind of a headache to position your meshes relative to the DOM elements of your web page.curtains.js was created with just that issue in mind.</p></blockquote>
  <p>Yes, exactly, connecting the DOM and WebGL. And that's pretty straightforward with curtains, one of the demos showcased is this:</p>
  <figure>
    <video src="media/dom.mp4" muted autoplay loop width="600"></video>
    <figcaption>
        So the titles are in HTML, and videos are distorted with WebGL. Isn't it cool?
    </figcaption>
  </figure>
  <p>And that's not it! We also have a postprocessing, FBOs, and full control over all of it with our custom shaders!</p>
  <h2>Our demo</h2>
  <p>So, yeah, curtains.js is pretty cool and i really advise you to try it. But let's get back to our problem  animating videos in WebGL.</p>
  <p>Turns out it's ridiculously easy with curtains.js. Here is the HTML we will be using:</p>
  
<pre>
    <div id="canvas"></div>
    <div class="wrapper">
        <div class="plane">
            <video src="1.mp4" data-sampler="first"></video>
            <video src="2.mp4" data-sampler="second"></video>
        </div>
    </div>
    <!-- and some custom shaders, because we will be using them -->
    <script id="vertexShader">...</script>
    <script id="fragmentShader">...</script>
</pre>
<p>But, HTML never've been exciting in HTML demos, so lets look at what javascript you need now to get video in WebGL:</p>
<pre>
    const curtains = new Curtains({
        container: "canvas",
        pixelRatio: Math.min(1.5, window.devicePixelRatio), 
    });
    const params = {
        vertexShaderID: "vertexShader",
        fragmentShaderID: "fragmentShader",
        uniforms: {
            transition: {
            name: "uTransition",
            type: "1f",
            value: 0,
            },
        },
    };

    const multiTexturesPlane = new Plane(
        curtains, 
        [...document.getElementsByClassName("plane")], // could be many Planes
        params
    );
</pre>
<p>Well, that's it! Because focus of this library is shaders connected to DOM, we dont have any Camera or Scene concepts here. And the setup becomes pretty straightforward. That hooked me up immedieately and i decided i need to share this with you guys, by using it in this demo.</p>
<p>Of course this is not the whole code. Because its video we need user action to play it. And then, we also need some animation of transition between slides. But that part is pretty common to all those kind of effects. In curtain.js events are used for that:</p>

<pre>
    multiTexturesPlane
    .onReady(() => {
      // navigation click events
      // play button
    })
    .onRender(() => {
      // updating time or anything
    });
</pre>
<p>And with that kind code you are ready to do any shader transitions like this one:</p>
<figure>
  <video src="media/transition.mp4" muted autoplay loop width="600"></video>
  <figcaption>
      Can you guess where this transition is coming from?
  </figcaption>
</figure>
<p>All the magic is happening in shaders, and just to show you that images and videos are the same in WebGL, i used one of the effects from <a href="https://tympanus.net/codrops/2019/11/05/creative-webgl-image-transitions/">my previous demo</a>. If you want to learn shaders, i advise you to check amazing <a href="https://thebookofshaders.com/">Book Of Shaders</a>.</p> 

<p>I hope you liked this short tutorial on getting videos into WebGL. Go get sources and play with the code!</p>



  








<!--   
  
  <p>Do you like unrolling things? Or may be you prefer rolling them in?</p>
  <p>I spent my childhood doing crepes. I loved those rolles.</p>
  <figure>
      <img src="assets/roll.jpg" alt="rolled crepes">
  </figure>
  <p>I guess, the time has come to unroll all the things. And to unroll as many rolls as possible i decided to automate this process with a bit of JS and WebGL. </p>
  
  <h2>Set Up</h2>
  <p>I will be using THREE.js for this animation, and set up a basic scene with some planes.<br>
  Just as in <a href="https://tympanus.net/codrops/2019/12/16/scroll-refraction-and-shader-effects-in-three-js-and-react/">this tutorial</a> by Paul Henschel we will replace all the images with those PlaneGeometry objects. So with this html in mind:</p>
  <pre class="brush:html">
  &lt;img src=&ldquo;owl.jpg&rdquo; class=&ldquo;js-image&gt;
  </pre>
  Once the page loads i will hide them:
  <pre class="brush:css">
  .js-image{opacity:0}
  </pre>
  <p>Then i will get dimensions and sizes of each image and position my 3D Planes exactly in place of each DOM image element.</p>
  <pre class="brush:js">
  MY_SCENE.add(
      new THREE.Mesh(
          new PlaneGeometry(640,480),  // some size of image
          new Material({texture:’owl.jpg’) // texture i took from DOM
      )
  )
  </pre>
  <p>Because rolling things with CSS or SVG is next to impossible, i needed all the power of WebGL, and i moved parts of my page into that world. But i like the idea of progressive enhancement, so we still have the usual images there in code, and if 3d is not working, user would just see them.</p>
  
  <p>After that, its quite easy to sync the scroll of the page with my 3D scene position. For that i used custom  smooth scroll described in <a href="https://tympanus.net/codrops/2019/07/10/how-to-add-smooth-scrolling-with-inner-image-animations-to-a-web-page/">amazing tutorial</a> by Mary Lou.  You should definitely check it out, as it works regardless of platform and actions that you use to scroll. You know this is usually the biggest pain with custom scrolling libraries.</p>
  
  <h1>Roll</h1>
  <p>So, we have it in 3D! Now with power of shaders we can do anything!<br>
  Well, anything <em>we</em> are capable of, at least =).</p>
  <figure>
      <video src="assets/wireframe.mp4" muted autoplay loop width="600"></video>
      <figcaption>
          Red parts are WebGL, everything else HTML.
      </figcaption>
  </figure>
  <p>I started from the end. I imagine every animation i do, as some function which takes number between 0 and 1 (i call it `progress`), and returns visual. So result of my imaginary RollFunction(0), should be something rolled. And RollFunction(1), should be just the default position of the plane.
  That’s how i got the last line of my animation:</p>
  <pre class="brush:glsl">
  vec3 finalPosition = mix(RolledPosition, DefaultPosition,progress);
  </pre>
  <p>I had DefaultPosition from the start, its usually called `position` (surprise). So all i needed, to create this RolledPosition, and change my progress!</p>
  
  <p>I figured a couple of ways to do that. I could have had another object(like an .obj file) done in some editor, or even fully exported animation from Blender or other program. <br>
  But i decided to transform DefaultPosition into RolledPosition with a couple of math functions inside my Vertex shader. So, imagine we have a plane lying in Z plane, so,  to roll something like that, you could do this:<p>
  
  <pre class="brush:glsl">
  RolledPosition.x = RADIUS*cos(position.x);
  RolledPosition.y = position.y; // stays the same
  RolledPosition.z = RADIUS*sin(position.x);
  </pre>
  
  <p>If you ever tried to draw circle yourself, you can easily guess where its coming from.  If not here is a famous GIF illustrating how it's all related:</p>
  <figure>
      <img src="assets/sine.gif" alt="sine + cosine = circle">
      <figcaption>
          See how those two functions are essentially part of circle.
      </figcaption>
  </figure>
  
  <p>Of course this would just make a (not so) perfect tube out of our plane, but just adding a couple of parameters here, can make it a real roll:</p>
  
  <pre class="brush:glsl">
  RADIUS *= 1 - position.x; // so it gets smaller when we roll plane
  newposition.z =  RADIUS*sin(position.x*TWO_PI);
  newposition.x =  RADIUS*cos(position.x*TWO_PI); 
  </pre>
  
  <p>And you will get something like that:</p>
  <figure>
  <iframe height="234" style="width: 100%;" scrolling="no" title="Archimedean spiral unroll animation" src="https://codepen.io/claimred/embed/JNZPPJ?height=234&theme-id=default&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
    See the Pen <a href='https://codepen.io/claimred/pen/JNZPPJ'>Archimedean spiral unroll animation</a> by Ted
    (<a href='https://codepen.io/claimred'>@claimred</a>) on <a href='https://codepen.io'>CodePen</a>.
  </iframe>
      <figcaption>
          It is done with the help of D3 library, but idea is the same.
      </figcaption>
  </figure>
  <p>This two-dimensional animation has really helped me to get the idea of rolling things. So i recommend you to dig into the code, its quite interesting!</p>
  
  <p>After that step, it was a matter of time and arithmetics to play a bit with progress, so i have this kind of animation for my plane:</p>
  <video src="assets/final.mp4" muted loop autoplay></video>
  <p>There are a number of other steps, to make angle parametric, and to make it a bit more beautiful with subtle shadows, but thats the most important part right here. Sine and Cosine functions are often at the core of all the cool things you see on the web! =).</p>
  
  <p>So let me know, do you like these rolls, and how much time have you spent scrolling it back and forth just to see ‘em roll! Have a nice day! =)</p>
  
   -->
  
  
  
  
  <!-- Can be added in the end of the article -->
  <h2>References and Credits</h2>
  <ul>
      <li>Photo by <a href="https://unsplash.com/photos/WLig6zy_lKw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">David Clode</a> on Unsplash</li>
  </ul>
  
